// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REWINDMESSAGE_REWIND_VIEWER_FBS_H_
#define FLATBUFFERS_GENERATED_REWINDMESSAGE_REWIND_VIEWER_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace rewind_viewer {
namespace fbs {

struct Vector2f;

struct Color;
struct ColorBuilder;

struct Circle;
struct CircleBuilder;

struct Arc;
struct ArcBuilder;

struct CircleSegment;
struct CircleSegmentBuilder;

struct Tiles;
struct TilesBuilder;

struct Rectangle;
struct RectangleBuilder;

struct Triangle;
struct TriangleBuilder;

struct Polyline;
struct PolylineBuilder;

struct LogText;
struct LogTextBuilder;

struct Popup;
struct PopupBuilder;

struct PopupRound;
struct PopupRoundBuilder;

struct CameraView;
struct CameraViewBuilder;

struct Layer;
struct LayerBuilder;

struct Map;
struct MapBuilder;

struct Options;
struct OptionsBuilder;

struct EndFrame;
struct EndFrameBuilder;

struct RewindMessage;
struct RewindMessageBuilder;

enum Command : uint8_t {
  Command_NONE = 0,
  Command_Arc = 1,
  Command_CameraView = 2,
  Command_Circle = 3,
  Command_CircleSegment = 4,
  Command_LogText = 5,
  Command_Options = 6,
  Command_Polyline = 7,
  Command_Popup = 8,
  Command_PopupRound = 9,
  Command_Rectangle = 10,
  Command_Tiles = 11,
  Command_Triangle = 12,
  Command_EndFrame = 13,
  Command_MIN = Command_NONE,
  Command_MAX = Command_EndFrame
};

inline const Command (&EnumValuesCommand())[14] {
  static const Command values[] = {
    Command_NONE,
    Command_Arc,
    Command_CameraView,
    Command_Circle,
    Command_CircleSegment,
    Command_LogText,
    Command_Options,
    Command_Polyline,
    Command_Popup,
    Command_PopupRound,
    Command_Rectangle,
    Command_Tiles,
    Command_Triangle,
    Command_EndFrame
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[15] = {
    "NONE",
    "Arc",
    "CameraView",
    "Circle",
    "CircleSegment",
    "LogText",
    "Options",
    "Polyline",
    "Popup",
    "PopupRound",
    "Rectangle",
    "Tiles",
    "Triangle",
    "EndFrame",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (::flatbuffers::IsOutRange(e, Command_NONE, Command_EndFrame)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<rewind_viewer::fbs::Arc> {
  static const Command enum_value = Command_Arc;
};

template<> struct CommandTraits<rewind_viewer::fbs::CameraView> {
  static const Command enum_value = Command_CameraView;
};

template<> struct CommandTraits<rewind_viewer::fbs::Circle> {
  static const Command enum_value = Command_Circle;
};

template<> struct CommandTraits<rewind_viewer::fbs::CircleSegment> {
  static const Command enum_value = Command_CircleSegment;
};

template<> struct CommandTraits<rewind_viewer::fbs::LogText> {
  static const Command enum_value = Command_LogText;
};

template<> struct CommandTraits<rewind_viewer::fbs::Options> {
  static const Command enum_value = Command_Options;
};

template<> struct CommandTraits<rewind_viewer::fbs::Polyline> {
  static const Command enum_value = Command_Polyline;
};

template<> struct CommandTraits<rewind_viewer::fbs::Popup> {
  static const Command enum_value = Command_Popup;
};

template<> struct CommandTraits<rewind_viewer::fbs::PopupRound> {
  static const Command enum_value = Command_PopupRound;
};

template<> struct CommandTraits<rewind_viewer::fbs::Rectangle> {
  static const Command enum_value = Command_Rectangle;
};

template<> struct CommandTraits<rewind_viewer::fbs::Tiles> {
  static const Command enum_value = Command_Tiles;
};

template<> struct CommandTraits<rewind_viewer::fbs::Triangle> {
  static const Command enum_value = Command_Triangle;
};

template<> struct CommandTraits<rewind_viewer::fbs::EndFrame> {
  static const Command enum_value = Command_EndFrame;
};

bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2f()
      : x_(0),
        y_(0) {
  }
  Vector2f(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vector2f, 8);

struct Color FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_FILL = 6
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool fill() const {
    return GetField<uint8_t>(VT_FILL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint8_t>(verifier, VT_FILL, 1) &&
           verifier.EndTable();
  }
};

struct ColorBuilder {
  typedef Color Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(Color::VT_VALUE, value, 0);
  }
  void add_fill(bool fill) {
    fbb_.AddElement<uint8_t>(Color::VT_FILL, static_cast<uint8_t>(fill), 0);
  }
  explicit ColorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Color> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Color>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Color> CreateColor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0,
    bool fill = false) {
  ColorBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_fill(fill);
  return builder_.Finish();
}

struct Circle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const rewind_viewer::fbs::Vector2f *center() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           verifier.EndTable();
  }
};

struct CircleBuilder {
  typedef Circle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Circle::VT_COLOR, color);
  }
  void add_center(const rewind_viewer::fbs::Vector2f *center) {
    fbb_.AddStruct(Circle::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(Circle::VT_RADIUS, radius, 0.0f);
  }
  explicit CircleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Circle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Circle>(end);
    fbb_.Required(o, Circle::VT_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<Circle> CreateCircle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const rewind_viewer::fbs::Vector2f *center = nullptr,
    float radius = 0.0f) {
  CircleBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add_color(color);
  return builder_.Finish();
}

struct Arc FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArcBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8,
    VT_START_ANGLE = 10,
    VT_END_ANGLE = 12
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const rewind_viewer::fbs::Vector2f *center() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float start_angle() const {
    return GetField<float>(VT_START_ANGLE, 0.0f);
  }
  float end_angle() const {
    return GetField<float>(VT_END_ANGLE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_START_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_END_ANGLE, 4) &&
           verifier.EndTable();
  }
};

struct ArcBuilder {
  typedef Arc Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Arc::VT_COLOR, color);
  }
  void add_center(const rewind_viewer::fbs::Vector2f *center) {
    fbb_.AddStruct(Arc::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(Arc::VT_RADIUS, radius, 0.0f);
  }
  void add_start_angle(float start_angle) {
    fbb_.AddElement<float>(Arc::VT_START_ANGLE, start_angle, 0.0f);
  }
  void add_end_angle(float end_angle) {
    fbb_.AddElement<float>(Arc::VT_END_ANGLE, end_angle, 0.0f);
  }
  explicit ArcBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Arc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Arc>(end);
    fbb_.Required(o, Arc::VT_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<Arc> CreateArc(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const rewind_viewer::fbs::Vector2f *center = nullptr,
    float radius = 0.0f,
    float start_angle = 0.0f,
    float end_angle = 0.0f) {
  ArcBuilder builder_(_fbb);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add_color(color);
  return builder_.Finish();
}

struct CircleSegment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircleSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8,
    VT_START_ANGLE = 10,
    VT_END_ANGLE = 12
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const rewind_viewer::fbs::Vector2f *center() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float start_angle() const {
    return GetField<float>(VT_START_ANGLE, 0.0f);
  }
  float end_angle() const {
    return GetField<float>(VT_END_ANGLE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_START_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_END_ANGLE, 4) &&
           verifier.EndTable();
  }
};

struct CircleSegmentBuilder {
  typedef CircleSegment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(CircleSegment::VT_COLOR, color);
  }
  void add_center(const rewind_viewer::fbs::Vector2f *center) {
    fbb_.AddStruct(CircleSegment::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CircleSegment::VT_RADIUS, radius, 0.0f);
  }
  void add_start_angle(float start_angle) {
    fbb_.AddElement<float>(CircleSegment::VT_START_ANGLE, start_angle, 0.0f);
  }
  void add_end_angle(float end_angle) {
    fbb_.AddElement<float>(CircleSegment::VT_END_ANGLE, end_angle, 0.0f);
  }
  explicit CircleSegmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CircleSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CircleSegment>(end);
    fbb_.Required(o, CircleSegment::VT_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<CircleSegment> CreateCircleSegment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const rewind_viewer::fbs::Vector2f *center = nullptr,
    float radius = 0.0f,
    float start_angle = 0.0f,
    float end_angle = 0.0f) {
  CircleSegmentBuilder builder_(_fbb);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add_color(color);
  return builder_.Finish();
}

struct Tiles FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TilesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_CELL_SIZE = 6,
    VT_ROW_SIZE = 8,
    VT_COLORS = 10
  };
  const rewind_viewer::fbs::Vector2f *position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_POSITION);
  }
  const rewind_viewer::fbs::Vector2f *cell_size() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_CELL_SIZE);
  }
  uint16_t row_size() const {
    return GetField<uint16_t>(VT_ROW_SIZE, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *colors() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_COLORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_POSITION, 4) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_CELL_SIZE, 4) &&
           VerifyField<uint16_t>(verifier, VT_ROW_SIZE, 2) &&
           VerifyOffsetRequired(verifier, VT_COLORS) &&
           verifier.VerifyVector(colors()) &&
           verifier.EndTable();
  }
};

struct TilesBuilder {
  typedef Tiles Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(const rewind_viewer::fbs::Vector2f *position) {
    fbb_.AddStruct(Tiles::VT_POSITION, position);
  }
  void add_cell_size(const rewind_viewer::fbs::Vector2f *cell_size) {
    fbb_.AddStruct(Tiles::VT_CELL_SIZE, cell_size);
  }
  void add_row_size(uint16_t row_size) {
    fbb_.AddElement<uint16_t>(Tiles::VT_ROW_SIZE, row_size, 0);
  }
  void add_colors(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> colors) {
    fbb_.AddOffset(Tiles::VT_COLORS, colors);
  }
  explicit TilesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tiles> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tiles>(end);
    fbb_.Required(o, Tiles::VT_POSITION);
    fbb_.Required(o, Tiles::VT_CELL_SIZE);
    fbb_.Required(o, Tiles::VT_COLORS);
    return o;
  }
};

inline ::flatbuffers::Offset<Tiles> CreateTiles(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    const rewind_viewer::fbs::Vector2f *cell_size = nullptr,
    uint16_t row_size = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> colors = 0) {
  TilesBuilder builder_(_fbb);
  builder_.add_colors(colors);
  builder_.add_cell_size(cell_size);
  builder_.add_position(position);
  builder_.add_row_size(row_size);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tiles> CreateTilesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    const rewind_viewer::fbs::Vector2f *cell_size = nullptr,
    uint16_t row_size = 0,
    const std::vector<uint32_t> *colors = nullptr) {
  auto colors__ = colors ? _fbb.CreateVector<uint32_t>(*colors) : 0;
  return rewind_viewer::fbs::CreateTiles(
      _fbb,
      position,
      cell_size,
      row_size,
      colors__);
}

struct Rectangle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RectangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_POSITION = 6,
    VT_SIZE = 8
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const rewind_viewer::fbs::Vector2f *position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_POSITION);
  }
  const rewind_viewer::fbs::Vector2f *size() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_SIZE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_POSITION, 4) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct RectangleBuilder {
  typedef Rectangle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Rectangle::VT_COLOR, color);
  }
  void add_position(const rewind_viewer::fbs::Vector2f *position) {
    fbb_.AddStruct(Rectangle::VT_POSITION, position);
  }
  void add_size(const rewind_viewer::fbs::Vector2f *size) {
    fbb_.AddStruct(Rectangle::VT_SIZE, size);
  }
  explicit RectangleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Rectangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Rectangle>(end);
    fbb_.Required(o, Rectangle::VT_POSITION);
    fbb_.Required(o, Rectangle::VT_SIZE);
    return o;
  }
};

inline ::flatbuffers::Offset<Rectangle> CreateRectangle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    const rewind_viewer::fbs::Vector2f *size = nullptr) {
  RectangleBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_position(position);
  builder_.add_color(color);
  return builder_.Finish();
}

struct Triangle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TriangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_POINTS = 6
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *points() const {
    return GetPointer<const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct TriangleBuilder {
  typedef Triangle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Triangle::VT_COLOR, color);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points) {
    fbb_.AddOffset(Triangle::VT_POINTS, points);
  }
  explicit TriangleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Triangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Triangle>(end);
    fbb_.Required(o, Triangle::VT_POINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Triangle> CreateTriangle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points = 0) {
  TriangleBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_color(color);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Triangle> CreateTriangleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const std::vector<rewind_viewer::fbs::Vector2f> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<rewind_viewer::fbs::Vector2f>(*points) : 0;
  return rewind_viewer::fbs::CreateTriangle(
      _fbb,
      color,
      points__);
}

struct Polyline FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PolylineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_POINTS = 6
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *points() const {
    return GetPointer<const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct PolylineBuilder {
  typedef Polyline Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Polyline::VT_COLOR, color);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points) {
    fbb_.AddOffset(Polyline::VT_POINTS, points);
  }
  explicit PolylineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Polyline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Polyline>(end);
    fbb_.Required(o, Polyline::VT_POINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Polyline> CreatePolyline(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points = 0) {
  PolylineBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_color(color);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Polyline> CreatePolylineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const std::vector<rewind_viewer::fbs::Vector2f> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<rewind_viewer::fbs::Vector2f>(*points) : 0;
  return rewind_viewer::fbs::CreatePolyline(
      _fbb,
      color,
      points__);
}

struct LogText FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogTextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct LogTextBuilder {
  typedef LogText Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(LogText::VT_TEXT, text);
  }
  explicit LogTextBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogText> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogText>(end);
    fbb_.Required(o, LogText::VT_TEXT);
    return o;
  }
};

inline ::flatbuffers::Offset<LogText> CreateLogText(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  LogTextBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogText> CreateLogTextDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return rewind_viewer::fbs::CreateLogText(
      _fbb,
      text__);
}

struct Popup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PopupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_AREA_POSITION = 6,
    VT_AREA_SIZE = 8
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const rewind_viewer::fbs::Vector2f *area_position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_AREA_POSITION);
  }
  const rewind_viewer::fbs::Vector2f *area_size() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_AREA_SIZE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_AREA_POSITION, 4) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_AREA_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct PopupBuilder {
  typedef Popup Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(Popup::VT_TEXT, text);
  }
  void add_area_position(const rewind_viewer::fbs::Vector2f *area_position) {
    fbb_.AddStruct(Popup::VT_AREA_POSITION, area_position);
  }
  void add_area_size(const rewind_viewer::fbs::Vector2f *area_size) {
    fbb_.AddStruct(Popup::VT_AREA_SIZE, area_size);
  }
  explicit PopupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Popup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Popup>(end);
    fbb_.Required(o, Popup::VT_TEXT);
    fbb_.Required(o, Popup::VT_AREA_POSITION);
    fbb_.Required(o, Popup::VT_AREA_SIZE);
    return o;
  }
};

inline ::flatbuffers::Offset<Popup> CreatePopup(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    const rewind_viewer::fbs::Vector2f *area_position = nullptr,
    const rewind_viewer::fbs::Vector2f *area_size = nullptr) {
  PopupBuilder builder_(_fbb);
  builder_.add_area_size(area_size);
  builder_.add_area_position(area_position);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Popup> CreatePopupDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const rewind_viewer::fbs::Vector2f *area_position = nullptr,
    const rewind_viewer::fbs::Vector2f *area_size = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return rewind_viewer::fbs::CreatePopup(
      _fbb,
      text__,
      area_position,
      area_size);
}

struct PopupRound FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PopupRoundBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_AREA_CENTER = 6,
    VT_AREA_RADIUS = 8
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const rewind_viewer::fbs::Vector2f *area_center() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_AREA_CENTER);
  }
  float area_radius() const {
    return GetField<float>(VT_AREA_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_AREA_CENTER, 4) &&
           VerifyField<float>(verifier, VT_AREA_RADIUS, 4) &&
           verifier.EndTable();
  }
};

struct PopupRoundBuilder {
  typedef PopupRound Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(PopupRound::VT_TEXT, text);
  }
  void add_area_center(const rewind_viewer::fbs::Vector2f *area_center) {
    fbb_.AddStruct(PopupRound::VT_AREA_CENTER, area_center);
  }
  void add_area_radius(float area_radius) {
    fbb_.AddElement<float>(PopupRound::VT_AREA_RADIUS, area_radius, 0.0f);
  }
  explicit PopupRoundBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PopupRound> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PopupRound>(end);
    fbb_.Required(o, PopupRound::VT_TEXT);
    fbb_.Required(o, PopupRound::VT_AREA_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<PopupRound> CreatePopupRound(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    const rewind_viewer::fbs::Vector2f *area_center = nullptr,
    float area_radius = 0.0f) {
  PopupRoundBuilder builder_(_fbb);
  builder_.add_area_radius(area_radius);
  builder_.add_area_center(area_center);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PopupRound> CreatePopupRoundDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const rewind_viewer::fbs::Vector2f *area_center = nullptr,
    float area_radius = 0.0f) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return rewind_viewer::fbs::CreatePopupRound(
      _fbb,
      text__,
      area_center,
      area_radius);
}

struct CameraView FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CameraViewBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_POSITION = 6,
    VT_VIEW_RADIUS = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const rewind_viewer::fbs::Vector2f *position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_POSITION);
  }
  float view_radius() const {
    return GetField<float>(VT_VIEW_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_POSITION, 4) &&
           VerifyField<float>(verifier, VT_VIEW_RADIUS, 4) &&
           verifier.EndTable();
  }
};

struct CameraViewBuilder {
  typedef CameraView Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CameraView::VT_NAME, name);
  }
  void add_position(const rewind_viewer::fbs::Vector2f *position) {
    fbb_.AddStruct(CameraView::VT_POSITION, position);
  }
  void add_view_radius(float view_radius) {
    fbb_.AddElement<float>(CameraView::VT_VIEW_RADIUS, view_radius, 0.0f);
  }
  explicit CameraViewBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CameraView> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CameraView>(end);
    fbb_.Required(o, CameraView::VT_NAME);
    fbb_.Required(o, CameraView::VT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<CameraView> CreateCameraView(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    float view_radius = 0.0f) {
  CameraViewBuilder builder_(_fbb);
  builder_.add_view_radius(view_radius);
  builder_.add_position(position);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CameraView> CreateCameraViewDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    float view_radius = 0.0f) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return rewind_viewer::fbs::CreateCameraView(
      _fbb,
      name__,
      position,
      view_radius);
}

struct Layer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_USE_PERMANENT_FRAME = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool use_permanent_frame() const {
    return GetField<uint8_t>(VT_USE_PERMANENT_FRAME, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_USE_PERMANENT_FRAME, 1) &&
           verifier.EndTable();
  }
};

struct LayerBuilder {
  typedef Layer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Layer::VT_ID, id, 0);
  }
  void add_use_permanent_frame(bool use_permanent_frame) {
    fbb_.AddElement<uint8_t>(Layer::VT_USE_PERMANENT_FRAME, static_cast<uint8_t>(use_permanent_frame), 0);
  }
  explicit LayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Layer> CreateLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    bool use_permanent_frame = false) {
  LayerBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_use_permanent_frame(use_permanent_frame);
  return builder_.Finish();
}

struct Map FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_SIZE = 6,
    VT_X_GRID = 8,
    VT_Y_GRID = 10
  };
  const rewind_viewer::fbs::Vector2f *position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_POSITION);
  }
  const rewind_viewer::fbs::Vector2f *size() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_SIZE);
  }
  uint16_t x_grid() const {
    return GetField<uint16_t>(VT_X_GRID, 0);
  }
  uint16_t y_grid() const {
    return GetField<uint16_t>(VT_Y_GRID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_POSITION, 4) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_SIZE, 4) &&
           VerifyField<uint16_t>(verifier, VT_X_GRID, 2) &&
           VerifyField<uint16_t>(verifier, VT_Y_GRID, 2) &&
           verifier.EndTable();
  }
};

struct MapBuilder {
  typedef Map Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(const rewind_viewer::fbs::Vector2f *position) {
    fbb_.AddStruct(Map::VT_POSITION, position);
  }
  void add_size(const rewind_viewer::fbs::Vector2f *size) {
    fbb_.AddStruct(Map::VT_SIZE, size);
  }
  void add_x_grid(uint16_t x_grid) {
    fbb_.AddElement<uint16_t>(Map::VT_X_GRID, x_grid, 0);
  }
  void add_y_grid(uint16_t y_grid) {
    fbb_.AddElement<uint16_t>(Map::VT_Y_GRID, y_grid, 0);
  }
  explicit MapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Map> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Map>(end);
    fbb_.Required(o, Map::VT_POSITION);
    fbb_.Required(o, Map::VT_SIZE);
    return o;
  }
};

inline ::flatbuffers::Offset<Map> CreateMap(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    const rewind_viewer::fbs::Vector2f *size = nullptr,
    uint16_t x_grid = 0,
    uint16_t y_grid = 0) {
  MapBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_position(position);
  builder_.add_y_grid(y_grid);
  builder_.add_x_grid(x_grid);
  return builder_.Finish();
}

struct Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAP = 4,
    VT_LAYER = 6
  };
  const rewind_viewer::fbs::Map *map() const {
    return GetPointer<const rewind_viewer::fbs::Map *>(VT_MAP);
  }
  const rewind_viewer::fbs::Layer *layer() const {
    return GetPointer<const rewind_viewer::fbs::Layer *>(VT_LAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           VerifyOffset(verifier, VT_LAYER) &&
           verifier.VerifyTable(layer()) &&
           verifier.EndTable();
  }
};

struct OptionsBuilder {
  typedef Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_map(::flatbuffers::Offset<rewind_viewer::fbs::Map> map) {
    fbb_.AddOffset(Options::VT_MAP, map);
  }
  void add_layer(::flatbuffers::Offset<rewind_viewer::fbs::Layer> layer) {
    fbb_.AddOffset(Options::VT_LAYER, layer);
  }
  explicit OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Options> CreateOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Map> map = 0,
    ::flatbuffers::Offset<rewind_viewer::fbs::Layer> layer = 0) {
  OptionsBuilder builder_(_fbb);
  builder_.add_layer(layer);
  builder_.add_map(map);
  return builder_.Finish();
}

struct EndFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EndFrameBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EndFrameBuilder {
  typedef EndFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EndFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EndFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EndFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EndFrame> CreateEndFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EndFrameBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RewindMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RewindMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND_TYPE = 4,
    VT_COMMAND = 6
  };
  rewind_viewer::fbs::Command command_type() const {
    return static_cast<rewind_viewer::fbs::Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const rewind_viewer::fbs::Arc *command_as_Arc() const {
    return command_type() == rewind_viewer::fbs::Command_Arc ? static_cast<const rewind_viewer::fbs::Arc *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::CameraView *command_as_CameraView() const {
    return command_type() == rewind_viewer::fbs::Command_CameraView ? static_cast<const rewind_viewer::fbs::CameraView *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Circle *command_as_Circle() const {
    return command_type() == rewind_viewer::fbs::Command_Circle ? static_cast<const rewind_viewer::fbs::Circle *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::CircleSegment *command_as_CircleSegment() const {
    return command_type() == rewind_viewer::fbs::Command_CircleSegment ? static_cast<const rewind_viewer::fbs::CircleSegment *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::LogText *command_as_LogText() const {
    return command_type() == rewind_viewer::fbs::Command_LogText ? static_cast<const rewind_viewer::fbs::LogText *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Options *command_as_Options() const {
    return command_type() == rewind_viewer::fbs::Command_Options ? static_cast<const rewind_viewer::fbs::Options *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Polyline *command_as_Polyline() const {
    return command_type() == rewind_viewer::fbs::Command_Polyline ? static_cast<const rewind_viewer::fbs::Polyline *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Popup *command_as_Popup() const {
    return command_type() == rewind_viewer::fbs::Command_Popup ? static_cast<const rewind_viewer::fbs::Popup *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::PopupRound *command_as_PopupRound() const {
    return command_type() == rewind_viewer::fbs::Command_PopupRound ? static_cast<const rewind_viewer::fbs::PopupRound *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Rectangle *command_as_Rectangle() const {
    return command_type() == rewind_viewer::fbs::Command_Rectangle ? static_cast<const rewind_viewer::fbs::Rectangle *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Tiles *command_as_Tiles() const {
    return command_type() == rewind_viewer::fbs::Command_Tiles ? static_cast<const rewind_viewer::fbs::Tiles *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Triangle *command_as_Triangle() const {
    return command_type() == rewind_viewer::fbs::Command_Triangle ? static_cast<const rewind_viewer::fbs::Triangle *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::EndFrame *command_as_EndFrame() const {
    return command_type() == rewind_viewer::fbs::Command_EndFrame ? static_cast<const rewind_viewer::fbs::EndFrame *>(command()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
};

template<> inline const rewind_viewer::fbs::Arc *RewindMessage::command_as<rewind_viewer::fbs::Arc>() const {
  return command_as_Arc();
}

template<> inline const rewind_viewer::fbs::CameraView *RewindMessage::command_as<rewind_viewer::fbs::CameraView>() const {
  return command_as_CameraView();
}

template<> inline const rewind_viewer::fbs::Circle *RewindMessage::command_as<rewind_viewer::fbs::Circle>() const {
  return command_as_Circle();
}

template<> inline const rewind_viewer::fbs::CircleSegment *RewindMessage::command_as<rewind_viewer::fbs::CircleSegment>() const {
  return command_as_CircleSegment();
}

template<> inline const rewind_viewer::fbs::LogText *RewindMessage::command_as<rewind_viewer::fbs::LogText>() const {
  return command_as_LogText();
}

template<> inline const rewind_viewer::fbs::Options *RewindMessage::command_as<rewind_viewer::fbs::Options>() const {
  return command_as_Options();
}

template<> inline const rewind_viewer::fbs::Polyline *RewindMessage::command_as<rewind_viewer::fbs::Polyline>() const {
  return command_as_Polyline();
}

template<> inline const rewind_viewer::fbs::Popup *RewindMessage::command_as<rewind_viewer::fbs::Popup>() const {
  return command_as_Popup();
}

template<> inline const rewind_viewer::fbs::PopupRound *RewindMessage::command_as<rewind_viewer::fbs::PopupRound>() const {
  return command_as_PopupRound();
}

template<> inline const rewind_viewer::fbs::Rectangle *RewindMessage::command_as<rewind_viewer::fbs::Rectangle>() const {
  return command_as_Rectangle();
}

template<> inline const rewind_viewer::fbs::Tiles *RewindMessage::command_as<rewind_viewer::fbs::Tiles>() const {
  return command_as_Tiles();
}

template<> inline const rewind_viewer::fbs::Triangle *RewindMessage::command_as<rewind_viewer::fbs::Triangle>() const {
  return command_as_Triangle();
}

template<> inline const rewind_viewer::fbs::EndFrame *RewindMessage::command_as<rewind_viewer::fbs::EndFrame>() const {
  return command_as_EndFrame();
}

struct RewindMessageBuilder {
  typedef RewindMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command_type(rewind_viewer::fbs::Command command_type) {
    fbb_.AddElement<uint8_t>(RewindMessage::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(::flatbuffers::Offset<void> command) {
    fbb_.AddOffset(RewindMessage::VT_COMMAND, command);
  }
  explicit RewindMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RewindMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RewindMessage>(end);
    fbb_.Required(o, RewindMessage::VT_COMMAND);
    return o;
  }
};

inline ::flatbuffers::Offset<RewindMessage> CreateRewindMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rewind_viewer::fbs::Command command_type = rewind_viewer::fbs::Command_NONE,
    ::flatbuffers::Offset<void> command = 0) {
  RewindMessageBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

inline bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_Arc: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Arc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CameraView: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::CameraView *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Circle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Circle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CircleSegment: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::CircleSegment *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_LogText: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::LogText *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Options: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Polyline: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Polyline *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Popup: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Popup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_PopupRound: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::PopupRound *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Rectangle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Rectangle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Tiles: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Tiles *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Triangle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Triangle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_EndFrame: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::EndFrame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

inline const rewind_viewer::fbs::RewindMessage *GetRewindMessage(const void *buf) {
  return ::flatbuffers::GetRoot<rewind_viewer::fbs::RewindMessage>(buf);
}

inline const rewind_viewer::fbs::RewindMessage *GetSizePrefixedRewindMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<rewind_viewer::fbs::RewindMessage>(buf);
}

inline bool VerifyRewindMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<rewind_viewer::fbs::RewindMessage>(nullptr);
}

inline bool VerifySizePrefixedRewindMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<rewind_viewer::fbs::RewindMessage>(nullptr);
}

inline void FinishRewindMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::RewindMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRewindMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::RewindMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace rewind_viewer

#endif  // FLATBUFFERS_GENERATED_REWINDMESSAGE_REWIND_VIEWER_FBS_H_
